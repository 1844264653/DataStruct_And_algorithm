~~~markdown
复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。
~~~

##### 既然跑一边代码就能统计，监控得到算法的执行时间和占用的内存大小，为什么还要做时间空间的复杂度分析呢？

 1. 测试结构非常依赖测试环境

 2. 测试结果受数据规模的影响很大

    e.g. 小规模数据，插入排序算法可能比快排要快



### 大O复杂度表示法

​		大O时间复杂度实际上并不具体表示代码执行时间，**而是表示代码执行时间随数据规模增长的变化趋势**

所以也叫**渐进时间复杂度**， 简称**时间复杂度**





## 时间复杂度分析

1. **只关注循环执行次数最多的一段代码**
2. 加法法则：**总复杂度等于量级最大的那段代码的复杂度**
3. 乘法法则：**嵌套代码的复杂度等于嵌套内外代码复杂度的乘积**



### 几种常见时间复杂度的实例分析

~~~math
常量阶 O(1)			指数阶 O（2^n）
对数阶 O(logn)			阶乘阶 O（n!）
线性阶 O(n)			
线性对数阶 O(nlogn)
平方阶级 O(n^2), 立方阶 O(n^3) ...
~~~

对于以上的复杂度量级，可以粗略的分为**多项式量级**和**非多项式量级**

**其中非多项式量级只有两个： O（2^n）和  O（n!）**



我们把时间复杂度为非多项式量级的算法问题叫做NP——非确定多项式



#### O（1）

常量级时间复杂度的一种表示方法

**一般情况瞎，只要算法中不存在循环语句，递归语句，即使有成千上万行代码，其时间复杂度也是O（1）**



#### O（logn）、O（nlogn）

对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度

~~~c
i = 1;
while (i <= n) {
    i = i *2
}
~~~

从代码可以看出，变量值i从1开始，每循环一次就乘以2，大于n，结束，则表达式是一个等比数列

~~~math
2^0*2^1*2^2..2^x = n
~~~

那解出x=log2n， 这样时间复杂度就是O（log2n） 由对数变换，忽略常数，可表示为O（logn）

那么，这段代码执行N次，时间复杂度就是O（nlogn）,归并排序，快速排序的时间复杂都是O（nlogn）



#### O（m+n）、O（m*n）

由两个数据规模来决定的

~~~c
int cal(int m, int n) {
    int sum_1 = 0; 
    int i = 1; 
    for (; i < m; ++i) { 
        sum_1 = sum_1 + i; 
    } 
    int sum_2 = 0; 
    int j = 1; 
    for (; j < n; ++j) { 
        sum_2 = sum_2 + j; 
    } 
    return sum_1 + sum_2;
}
~~~



## 空间复杂度分析

时间复杂度的全称是渐进时间复杂度，表示宣发的执行时间于数据规模之间的增长关系。

空间复杂度的全程就叫做**渐进空间复杂度， 表示算法的存储空间和数据规模之间的增长关系**

空间复杂度的分析比时间复杂度的分析简单的多，对比就行了