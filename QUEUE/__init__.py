#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Time    : 2020/1/13 10:24
# @Author  : sakura
# @Site    : 
# @File    : __init__.py.py
# @Software: PyCharm

"""
    我们都知道cpu的资源是有限的，任务的处理速度和线程个数并不是线性正相关。相反，过多的线程反而会导致cpu频繁切换，处理性能下降
    所以线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设计好


    先进先出的数据结构： 入队enqueue  出队dequeue    ——也是一种操作受限线性表数据结构
    链表实现：链式队列
    数组实现：顺序队列

    1.  循环队列   ----应用最广泛
    2.  阻塞队列  ：队列为空，从队头取数据被阻塞；队列满，插入数据会被阻塞——生产者—消费者模型的实现（Kaffa）
    3.  并发队列  ：多线程情况下，多个线程同时操作队列，这个时候需要保证线程安全——线程安全的队列叫作并发队列。如何实现线程安全？


    e.g.
       高性能队列 Disruptor  Linux环形缓存
       java concurrent并发包利用ArrayBlockingQueue来实现公平锁
       python3.6 以上版本有 concurrency的一个并发包


    考虑问题： 循环队列    队列为空和满的条件——取模操作
               队列内的搬移操作：时间复杂度是多少？
               并发队列如何实现线程安全？ 对enqueue和dequeue直接枷锁粒度太大导致并发较低？
                        ——CAS原子操作（顺序队列比链式队列应用更加广泛的原因）—— Compare  and Set（或者swap）
                            ——比较再交换/设置

    应用：  顺序队列和链式队列的应用有什么不一样呢？
        1.  基于链表的实现方式，可以实现那一个支持无限排队的无界队列（unbounded queue）
            但是可能会导致过多的请求排队等待，请求处理的响应时间过长
            所以针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的

        2.  而基于数组实现的有界队列（bounded queue），队列大小有限，所以线程池中排队的请求超过队列大小时，
            接下来的请求会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。
            不过设置一个合理的队列大小，也是非常讲究的
            队列太大导致等待的请求过多；队列太小会导致无法充分利用系统资源发挥最大的性能

"""